
'use strict';

var events = require('events'),
    util = require('util');

var EventEmitter = events.EventEmitter;

/**
 * New divider
 * @param options
 * @constructor
 */
function Divider(options) {
    EventEmitter.call(this);

    this._concurrency = options.concurrency || 1;
    this._partSize = options.part || 1024;
    this._chunksIndex = options.index || 1;

    this._chunksBuffer = [];
    this._chunksSize = 0;

    this._chunksStarted = 0;
    this._chunksWorking = 0;
    this._chunksNext = 0;

    this._isDelayFinish = false;
    this._isFinish = false;
}

util.inherits(Divider, EventEmitter);

/**
 * Get current concurrency value
 * @returns {number}
 */
Divider.prototype.getConcurrency = function() {
    return this._chunksWorking;
};

/**
 * Get current index of part
 * @returns {number}
 */
Divider.prototype.getIndex = function() {
    return this._chunksIndex;
};

/**
 * Set init index
 * @param index
 */
Divider.prototype.setIndex = function(index) {
    this._chunksIndex = index;
};

/**
 * Write part of data
 * @param chunk
 * @param next
 * @returns {*}
 */
Divider.prototype.write = function(chunk, next) {
    this._chunksSize += chunk.length;

    var overSize = this._chunksSize - this._partSize;

    if (overSize < 0) {
        this._chunksBuffer.push(chunk);
        return next(null);
    }

    var diffSize = chunk.length - overSize,
        tempData = chunk.slice(diffSize),
        partData = this._chunksBuffer;

    this._chunksSize = tempData.length;
    this._chunksBuffer = [tempData];

    partData.push(chunk.slice(0, diffSize));
    this._parallelHandler(partData, this._chunksIndex++, next);
};

/**
 * Finish collect data
 */
Divider.prototype.finish = function(next) {
    this._isFinish = true;

    // Empty buffer + no parts in progress
    if (!this._chunksBuffer.length && this._chunksWorking === 0) {
        this._chunksNext++;
        return process.nextTick(next);
    }

    // Empty buffer + some parts in progress
    if (!this._chunksBuffer.length && this._chunksWorking > 0) {
        return this._isDelayFinish = true;
    }

    var self = this;

    this._chunksStarted++;
    this._chunksWorking++;

    this.emit('part', { data: Buffer.concat(this._chunksBuffer), index: this._chunksIndex }, function(err) {
        self._chunksBuffer = null;
        self._chunksWorking--;

        // No parts in progress - can finished
        if (self._chunksWorking === 0) {
            self._chunksNext++;
            return next(err);
        }

        // Some parts in progress - subsribe to event
        self._isDelayFinish = true;
        self.on('_finish', next);
    });
};

/**
 * Parallel parts processing
 * @param partData
 * @param partIndex
 * @param next
 * @private
 */
Divider.prototype._parallelHandler = function(partData, partIndex, next) {
    var self = this;

    this._chunksStarted++;
    this._chunksWorking++;

    if (this._concurrency === 1) {
        return this.emit('part', { data: Buffer.concat(partData), index: partIndex }, function(err) {
            self._chunksWorking--;
            next(err);
        });
    }

    this.emit('part', { data: Buffer.concat(partData), index: partIndex }, function(err) {
        self._chunksWorking--;

        if (!self._isFinish) {
            self._chunksNext++;
            return next(err);
        }

        // Delayed finish + no data in progress
        if (self._isDelayFinish && self._chunksWorking === 0) {
            self.emit('_finish');
        }

        next = null;
    });

    if (this._chunksStarted < this._concurrency) {
        this._chunksNext++;
        process.nextTick(next);
    }
};

/**
 * Create new divider
 * @param options
 * @returns {Divider}
 */
module.exports = function(options) {
    return new Divider(options);
};
